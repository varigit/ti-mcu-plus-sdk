<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM62x MCU+ SDK: ECC_AGGR Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM62x MCU+ SDK
   &#160;<span id="projectnumber">08.06.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__SDL__ECC__AGGR__FUNCTION.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ECC_AGGR Functions<div class="ingroups"><a class="el" href="group__SDL__ECC__AGGR__API.html">APIs for SDL ECC</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Introduction</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga487ebb75e9964e49260817e5cb080d7d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga487ebb75e9964e49260817e5cb080d7d">SDL_ecc_aggrGetRevision</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t *pRev)</td></tr>
<tr class="separator:ga487ebb75e9964e49260817e5cb080d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd92b4adf0d5805df18662b1e1c5cd92"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t *pNumRams)</td></tr>
<tr class="separator:gafd92b4adf0d5805df18662b1e1c5cd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cdd85d792ede784563f8670b43cdf32"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga8cdd85d792ede784563f8670b43cdf32">SDL_ecc_aggrReadEccRamReg</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, uint32_t regOffset, uint32_t *pRegVal)</td></tr>
<tr class="separator:ga8cdd85d792ede784563f8670b43cdf32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bcf28a806952abc7ed596a045c04e96"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga4bcf28a806952abc7ed596a045c04e96">SDL_ecc_aggrReadEccRamWrapRevReg</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, uint32_t *pRegVal)</td></tr>
<tr class="separator:ga4bcf28a806952abc7ed596a045c04e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54f6fb74b621f7eab5f62392543bb3c6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga54f6fb74b621f7eab5f62392543bb3c6">SDL_ecc_aggrReadEccRamCtrlReg</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, uint32_t *pRegVal)</td></tr>
<tr class="separator:ga54f6fb74b621f7eab5f62392543bb3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59d2dd49c4c93da9a9bef8c979e6c3e8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga59d2dd49c4c93da9a9bef8c979e6c3e8">SDL_ecc_aggrReadEccRamErrCtrlReg</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, uint32_t instSelect, uint32_t *pRegVal)</td></tr>
<tr class="separator:ga59d2dd49c4c93da9a9bef8c979e6c3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36c25ecf06d00cb6451b7cc4ce6056a8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga36c25ecf06d00cb6451b7cc4ce6056a8">SDL_ecc_aggrReadEccRamErrStatReg</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, uint32_t instSelect, uint32_t *pRegVal)</td></tr>
<tr class="separator:ga36c25ecf06d00cb6451b7cc4ce6056a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79a143607703eb825b82b2ae4f21b649"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga79a143607703eb825b82b2ae4f21b649">SDL_ecc_aggrWriteEccRamReg</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, uint32_t regOffset, uint32_t val)</td></tr>
<tr class="separator:ga79a143607703eb825b82b2ae4f21b649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb77ded1c6fced05669f36d80b1cd4e0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gadb77ded1c6fced05669f36d80b1cd4e0">SDL_ecc_aggrWriteEccRamCtrlReg</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, uint32_t val)</td></tr>
<tr class="separator:gadb77ded1c6fced05669f36d80b1cd4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71bae87a953387630c5d686d15c234f9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga71bae87a953387630c5d686d15c234f9">SDL_ecc_aggrWriteEccRamErrCtrlReg</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, uint32_t instSelect, uint32_t val)</td></tr>
<tr class="separator:ga71bae87a953387630c5d686d15c234f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed30558bf07c131f4ef70a104b9c75fb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gaed30558bf07c131f4ef70a104b9c75fb">SDL_ecc_aggrWriteEccRamErrStatReg</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, uint32_t instSelect, uint32_t val)</td></tr>
<tr class="separator:gaed30558bf07c131f4ef70a104b9c75fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59f6dc0f4ee61957129476dcf2989ac0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga59f6dc0f4ee61957129476dcf2989ac0">SDL_ecc_aggrConfigEccRam</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, bool bEnable, bool bEccCheck, bool bEnableRMW)</td></tr>
<tr class="separator:ga59f6dc0f4ee61957129476dcf2989ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2193fa2fc3659092468fd3f7d34b287"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gaf2193fa2fc3659092468fd3f7d34b287">SDL_ecc_aggrVerifyConfigEccRam</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, bool bEnable, bool bEccCheck, bool bEnableRMW)</td></tr>
<tr class="separator:gaf2193fa2fc3659092468fd3f7d34b287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53ae9672250cc052634421b34de0331d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga53ae9672250cc052634421b34de0331d">SDL_ecc_aggrGetEccRamErrorStatus</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, <a class="el" href="structSDL__Ecc__AggrEccRamErrorStatusInfo.html">SDL_Ecc_AggrEccRamErrorStatusInfo</a> *pEccErrorStatus)</td></tr>
<tr class="separator:ga53ae9672250cc052634421b34de0331d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a8b03aaf8e509fcf60aa363dcb93fbb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga8a8b03aaf8e509fcf60aa363dcb93fbb">SDL_ecc_aggrForceEccRamError</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, const <a class="el" href="structSDL__Ecc__AggrErrorInfo.html">SDL_Ecc_AggrErrorInfo</a> *pEccForceError)</td></tr>
<tr class="separator:ga8a8b03aaf8e509fcf60aa363dcb93fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafda9eea0e7a76e6f1154055e46eae366"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafda9eea0e7a76e6f1154055e46eae366">SDL_ecc_aggrReadEDCInterconnectReg</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, uint32_t regOffset, uint32_t *pRegVal)</td></tr>
<tr class="separator:gafda9eea0e7a76e6f1154055e46eae366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49c65657322bb71648c2546d7cb06786"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga49c65657322bb71648c2546d7cb06786">SDL_ecc_aggrWriteEDCInterconnectReg</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, uint32_t regOffset, uint32_t val)</td></tr>
<tr class="separator:ga49c65657322bb71648c2546d7cb06786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fdfa8c64b72e041b8cfe0dad6a0290c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga6fdfa8c64b72e041b8cfe0dad6a0290c">SDL_ecc_aggrConfigEDCInterconnect</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, bool bEccCheck)</td></tr>
<tr class="separator:ga6fdfa8c64b72e041b8cfe0dad6a0290c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae02e143af4ec1e6b395a6f34a1b6cf91"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gae02e143af4ec1e6b395a6f34a1b6cf91">SDL_ecc_aggrVerifyConfigEDCInterconnect</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, bool bEccCheck)</td></tr>
<tr class="separator:gae02e143af4ec1e6b395a6f34a1b6cf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5ab784ded2331716bafb8c4cd56f105"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gaf5ab784ded2331716bafb8c4cd56f105">SDL_ecc_aggrGetEDCInterconnectErrorStatus</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, <a class="el" href="structSDL__Ecc__AggrEDCInterconnectErrorStatusInfo.html">SDL_Ecc_AggrEDCInterconnectErrorStatusInfo</a> *pEccErrorStatus)</td></tr>
<tr class="separator:gaf5ab784ded2331716bafb8c4cd56f105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea7ddb7bdaec0006bd369812203a9869"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gaea7ddb7bdaec0006bd369812203a9869">SDL_ecc_aggrForceEDCInterconnectError</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, const <a class="el" href="structSDL__Ecc__AggrEDCInterconnectErrorInfo.html">SDL_Ecc_AggrEDCInterconnectErrorInfo</a> *pEccForceError)</td></tr>
<tr class="separator:gaea7ddb7bdaec0006bd369812203a9869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3d7dd50b8746a91d710fc804e6c7f4f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gaa3d7dd50b8746a91d710fc804e6c7f4f">SDL_ecc_aggrAckIntr</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc)</td></tr>
<tr class="separator:gaa3d7dd50b8746a91d710fc804e6c7f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga415b73a48902d7d2263f7b1ede627780"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga415b73a48902d7d2263f7b1ede627780">SDL_ecc_aggrIsEccRamIntrPending</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc, bool *pIsPend)</td></tr>
<tr class="separator:ga415b73a48902d7d2263f7b1ede627780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8320e329b155a7e8e13104509a010671"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga8320e329b155a7e8e13104509a010671">SDL_ecc_aggrSetEccRamIntrPending</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc)</td></tr>
<tr class="separator:ga8320e329b155a7e8e13104509a010671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4ea124c43807001101e9aa63d0c521c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gac4ea124c43807001101e9aa63d0c521c">SDL_ecc_aggrSetEccRamNIntrPending</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc, uint32_t numEvents)</td></tr>
<tr class="separator:gac4ea124c43807001101e9aa63d0c521c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1371231c7a8bb6d9b501bec2bc0363f3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga1371231c7a8bb6d9b501bec2bc0363f3">SDL_ecc_aggrClrEccRamIntrPending</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc)</td></tr>
<tr class="separator:ga1371231c7a8bb6d9b501bec2bc0363f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2a1abd9224641cb30ccbfa487676539"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gae2a1abd9224641cb30ccbfa487676539">SDL_ecc_aggrClrEccRamNIntrPending</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc, uint32_t numEvents)</td></tr>
<tr class="separator:gae2a1abd9224641cb30ccbfa487676539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacacd3470241b054a127dc43044385667"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gacacd3470241b054a127dc43044385667">SDL_ecc_aggrIsEDCInterconnectIntrPending</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc, bool *pIsPend)</td></tr>
<tr class="separator:gacacd3470241b054a127dc43044385667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19aa06a05d0208045e9d831ae731a4fc"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga19aa06a05d0208045e9d831ae731a4fc">SDL_ecc_aggrSetEDCInterconnectNIntrPending</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#ga6dffb98cb4d267d06430adec7bba1b6b">SDL_Ecc_AggrEDCErrorSubType</a> subType, uint32_t numEvents)</td></tr>
<tr class="separator:ga19aa06a05d0208045e9d831ae731a4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga872ad1ef6ab69b7cc8cbee521a8f1477"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga872ad1ef6ab69b7cc8cbee521a8f1477">SDL_ecc_aggrClrEDCInterconnectNIntrPending</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#ga6dffb98cb4d267d06430adec7bba1b6b">SDL_Ecc_AggrEDCErrorSubType</a> subType, uint32_t numEvents)</td></tr>
<tr class="separator:ga872ad1ef6ab69b7cc8cbee521a8f1477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e879da096e53d75be140c185280e91c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga7e879da096e53d75be140c185280e91c">SDL_ecc_aggrIsIntrPending</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc, bool *pIsPend)</td></tr>
<tr class="separator:ga7e879da096e53d75be140c185280e91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3228be72cf5ae3a8a29b9568a6709d37"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga3228be72cf5ae3a8a29b9568a6709d37">SDL_ecc_aggrIsAnyIntrPending</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, bool *pIsPend)</td></tr>
<tr class="separator:ga3228be72cf5ae3a8a29b9568a6709d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf59636079aff6ba0368615abee362d66"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gaf59636079aff6ba0368615abee362d66">SDL_ecc_aggrEnableIntr</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc)</td></tr>
<tr class="separator:gaf59636079aff6ba0368615abee362d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga181414a69152a8365a694bd8188fbcc5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga181414a69152a8365a694bd8188fbcc5">SDL_ecc_aggrDisableIntr</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc)</td></tr>
<tr class="separator:ga181414a69152a8365a694bd8188fbcc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c91cbaa03176e6debbe719c9e0ede79"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga5c91cbaa03176e6debbe719c9e0ede79">SDL_ecc_aggrEnableAllIntr</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId)</td></tr>
<tr class="separator:ga5c91cbaa03176e6debbe719c9e0ede79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga122b80435ec40e0c48338f0277d85c52"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga122b80435ec40e0c48338f0277d85c52">SDL_ecc_aggrDisableAllIntr</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, uint32_t ramId)</td></tr>
<tr class="separator:ga122b80435ec40e0c48338f0277d85c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2e801ae78ea619187cbdce792cfe35b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gad2e801ae78ea619187cbdce792cfe35b">SDL_ecc_aggrEnableIntrs</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc)</td></tr>
<tr class="separator:gad2e801ae78ea619187cbdce792cfe35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb6719881e9194c28fb4cf1be7cd9170"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gacb6719881e9194c28fb4cf1be7cd9170">SDL_ecc_aggrDisableIntrs</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, <a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a> intrSrc)</td></tr>
<tr class="separator:gacb6719881e9194c28fb4cf1be7cd9170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga555808e1bf039ab2222e7fb94a606f7b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga555808e1bf039ab2222e7fb94a606f7b">SDL_ecc_aggrEnableAllIntrs</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs)</td></tr>
<tr class="separator:ga555808e1bf039ab2222e7fb94a606f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b47f308f8ae4660723caf125a73f960"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga0b47f308f8ae4660723caf125a73f960">SDL_ecc_aggrDisableAllIntrs</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs)</td></tr>
<tr class="separator:ga0b47f308f8ae4660723caf125a73f960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa566e02e16ebbb5355649a2706bf44e0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gaa566e02e16ebbb5355649a2706bf44e0">SDL_ecc_aggrReadStaticRegs</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, <a class="el" href="structSDL__ECC__staticRegs.html">SDL_ECC_staticRegs</a> *pEccAggrStaticRegs)</td></tr>
<tr class="separator:gaa566e02e16ebbb5355649a2706bf44e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6c8ec50211c9b8485e2fc2b4076e34c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gae6c8ec50211c9b8485e2fc2b4076e34c">SDL_ecc_aggrIntrEnableCtrl</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, const <a class="el" href="structSDL__ecc__aggrEnableCtrl.html">SDL_ecc_aggrEnableCtrl</a> *pEnableCtrl)</td></tr>
<tr class="separator:gae6c8ec50211c9b8485e2fc2b4076e34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga315328ad1eda006e9c8729ad81fb2cb9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga315328ad1eda006e9c8729ad81fb2cb9">SDL_ecc_aggrIntrStatusCtrl</a> (<a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, const <a class="el" href="structSDL__ecc__aggrStatusCtrl.html">SDL_ecc_aggrStatusCtrl</a> *pStatusCtrl)</td></tr>
<tr class="separator:ga315328ad1eda006e9c8729ad81fb2cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcf84d60a080c7f339f4e0d300cce4b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga7fcf84d60a080c7f339f4e0d300cce4b">SDL_ecc_aggrIntrGetStatus</a> (const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *pEccAggrRegs, <a class="el" href="structSDL__ecc__aggrStatusCtrl.html">SDL_ecc_aggrStatusCtrl</a> *pStatusCtrl)</td></tr>
<tr class="separator:ga7fcf84d60a080c7f339f4e0d300cce4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga487ebb75e9964e49260817e5cb080d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga487ebb75e9964e49260817e5cb080d7d">&#9670;&nbsp;</a></span>SDL_ecc_aggrGetRevision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrGetRevision </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pRev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrGetRevision</b> </p>
<p><b>Description</b> <br  />
 This function returns the revision information for the ECC Aggregator</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 pRev A pointer (of type uint32_t) to hold the rev ID value of the ECC Aggregator module Revision information. See design specification for details.</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gafd92b4adf0d5805df18662b1e1c5cd92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd92b4adf0d5805df18662b1e1c5cd92">&#9670;&nbsp;</a></span>SDL_ecc_aggrGetNumRams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrGetNumRams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pNumRams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrGetNumRams</b> </p>
<p><b>Description</b> <br  />
 This function returns the number of RAMs serviced by this ECC Aggregator</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 pNumRams A pointer (of type uint32_t) to hold the value of number of RAMs serviced by this ECC Aggregator</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga8cdd85d792ede784563f8670b43cdf32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cdd85d792ede784563f8670b43cdf32">&#9670;&nbsp;</a></span>SDL_ecc_aggrReadEccRamReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrReadEccRamReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pRegVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrReadEccRamReg</b> </p>
<p><b>Description</b> <br  />
 This function reads the specified ECC wrapper register from the specific ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 regOffset Byte offset of the ECC wrapper register to read (must be in the range of 0x10..0x24) <br  />
 pRegVal A pointer (of uint32_t) to hold the value of the specified ECC wrapper register</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the arguments such as ramId and/or regOffset are invalid</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga4bcf28a806952abc7ed596a045c04e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bcf28a806952abc7ed596a045c04e96">&#9670;&nbsp;</a></span>SDL_ecc_aggrReadEccRamWrapRevReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrReadEccRamWrapRevReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pRegVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrReadEccRamWrapRevReg</b> </p>
<p><b>Description</b> <br  />
 This function reads the ECC wrapper revision register from the specific ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1)</p>
<p><br  />
 pRegVal A pointer (of type uint32_t) to hold the value of the ECC wrapper revision register</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga54f6fb74b621f7eab5f62392543bb3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54f6fb74b621f7eab5f62392543bb3c6">&#9670;&nbsp;</a></span>SDL_ecc_aggrReadEccRamCtrlReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrReadEccRamCtrlReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pRegVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrReadEccRamCtrlReg</b> </p>
<p><b>Description</b> <br  />
 This function reads the specified ECC wrapper control register from the specific ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1)</p>
<p><br  />
 pRegVal A pointer (of type uint32_t) to hold the value of the ECC control register</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga59d2dd49c4c93da9a9bef8c979e6c3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59d2dd49c4c93da9a9bef8c979e6c3e8">&#9670;&nbsp;</a></span>SDL_ecc_aggrReadEccRamErrCtrlReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrReadEccRamErrCtrlReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pRegVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrReadEccRamErrCtrlReg</b> </p>
<p><b>Description</b> <br  />
 This function reads the specified ECC wrapper error control register from the specific ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 instSelect Instance selector (0..1) of the specified register to read</p>
<p><br  />
 pRegVal A pointer (of type uint32_t) to hold the value of the ECC Error control register</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments </p>

</div>
</div>
<a id="ga36c25ecf06d00cb6451b7cc4ce6056a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36c25ecf06d00cb6451b7cc4ce6056a8">&#9670;&nbsp;</a></span>SDL_ecc_aggrReadEccRamErrStatReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrReadEccRamErrStatReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pRegVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrReadEccRamErrStatReg</b> </p>
<p><b>Description</b> <br  />
 This function reads the specified ECC wrapper error status register from the specific ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 instSelect Instance selector (0..1) of the specified register to read</p>
<p><br  />
 pRegVal A pointer (of type uint32_t) to hold the value of the ECC error status register</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments </p>

</div>
</div>
<a id="ga79a143607703eb825b82b2ae4f21b649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79a143607703eb825b82b2ae4f21b649">&#9670;&nbsp;</a></span>SDL_ecc_aggrWriteEccRamReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrWriteEccRamReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrWriteEccRamReg</b> </p>
<p><b>Description</b> <br  />
 This function writes a value into the specified ECC wrapper register in the specific ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 regOffset Byte offset of the ECC wrapper register to write (must be in the range of 0x10..0x24) <br  />
 val The 32-bit value to write into the register</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gadb77ded1c6fced05669f36d80b1cd4e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb77ded1c6fced05669f36d80b1cd4e0">&#9670;&nbsp;</a></span>SDL_ecc_aggrWriteEccRamCtrlReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrWriteEccRamCtrlReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrWriteEccRamCtrlReg</b> </p>
<p><b>Description</b> <br  />
 This function write a value into the ECC wrapper control register in the specific ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 val The 32-bit value to write into the register</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga71bae87a953387630c5d686d15c234f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71bae87a953387630c5d686d15c234f9">&#9670;&nbsp;</a></span>SDL_ecc_aggrWriteEccRamErrCtrlReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrWriteEccRamErrCtrlReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrWriteEccRamErrCtrlReg</b> </p>
<p><b>Description</b> <br  />
 This function writes a value into the specified ECC wrapper error control register in the specific ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 instSelect Instance selector (0..1) of the specified register to write <br  />
 val The 32-bit value to write into the register</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gaed30558bf07c131f4ef70a104b9c75fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed30558bf07c131f4ef70a104b9c75fb">&#9670;&nbsp;</a></span>SDL_ecc_aggrWriteEccRamErrStatReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrWriteEccRamErrStatReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instSelect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrWriteEccRamErrStatReg</b> </p>
<p><b>Description</b> <br  />
 This function write a value into the specified ECC wrapper error status register in the specific ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 instSelect Instance selector (0..1) of the specified register to write <br  />
 val The 32-bit value to write into the register</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga59f6dc0f4ee61957129476dcf2989ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59f6dc0f4ee61957129476dcf2989ac0">&#9670;&nbsp;</a></span>SDL_ecc_aggrConfigEccRam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrConfigEccRam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEccCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnableRMW</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrConfigEccRam</b> </p>
<p><b>Description</b> <br  />
 This function is used to configure the ECC capabilities of the specified ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 bEnable If true, then enable ECC generation. ECC is completely bypassed if both fEnable and fEccCheck are 0. <br  />
 bEccCheck If true, then enable ECC check. ECC is completely bypassed if both fEnable and fEccCheck are 0. <br  />
 bfEnableRMW If true, then enable read-modify-write on partial word writes</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gaf2193fa2fc3659092468fd3f7d34b287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2193fa2fc3659092468fd3f7d34b287">&#9670;&nbsp;</a></span>SDL_ecc_aggrVerifyConfigEccRam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrVerifyConfigEccRam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEccCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnableRMW</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrVerifyConfigEccRam</b> </p>
<p><b>Description</b> <br  />
 This function is used to verify the configure the ECC capabilities of the specified ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 bEnable If true, then enable ECC generation. ECC is completely bypassed if both fEnable and fEccCheck are 0. <br  />
 bEccCheck If true, then enable ECC check. ECC is completely bypassed if both fEnable and fEccCheck are 0. <br  />
 bfEnableRMW If true, then enable read-modify-write on partial word writes</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success, indicates the configuration is successful <br  />
 SDL_EFAIL Failure, indicates the expected configuration failed <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 <a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga59f6dc0f4ee61957129476dcf2989ac0">SDL_ecc_aggrConfigEccRam()</a> is called previously with the same arguments</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga53ae9672250cc052634421b34de0331d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53ae9672250cc052634421b34de0331d">&#9670;&nbsp;</a></span>SDL_ecc_aggrGetEccRamErrorStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrGetEccRamErrorStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL__Ecc__AggrEccRamErrorStatusInfo.html">SDL_Ecc_AggrEccRamErrorStatusInfo</a> *&#160;</td>
          <td class="paramname"><em>pEccErrorStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrGetEccRamErrorStatus</b> </p>
<p><b>Description</b> <br  />
 This function is used to get the error status of the specified ECC Wrapper type RAM id</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 pEccErrorStatus A pointer to a <a class="el" href="structSDL__Ecc__AggrEccRamErrorStatusInfo.html" title="This structure contains error status information returned by the SDL_ecc_aggrGetEccRamGetErrorStatus ...">SDL_Ecc_AggrEccRamErrorStatusInfo</a> structure containing returned error information</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga8a8b03aaf8e509fcf60aa363dcb93fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a8b03aaf8e509fcf60aa363dcb93fbb">&#9670;&nbsp;</a></span>SDL_ecc_aggrForceEccRamError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrForceEccRamError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSDL__Ecc__AggrErrorInfo.html">SDL_Ecc_AggrErrorInfo</a> *&#160;</td>
          <td class="paramname"><em>pEccForceError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrForceEccRamError</b> </p>
<p><b>Description</b> <br  />
 This function is used to force an ECC error on the specified ECC Wrapper type RAM id</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 pEccForceError A pointer to a <a class="el" href="structSDL__Ecc__AggrErrorInfo.html" title="This structure contains error forcing information used by the SDL_ecc_aggrForceEccRamError function.">SDL_Ecc_AggrErrorInfo</a> structure containing force error information</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gafda9eea0e7a76e6f1154055e46eae366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafda9eea0e7a76e6f1154055e46eae366">&#9670;&nbsp;</a></span>SDL_ecc_aggrReadEDCInterconnectReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrReadEDCInterconnectReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pRegVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrReadEDCInterconnectReg</b> </p>
<p><b>Description</b> <br  />
 This function reads the specified EDC interconnect register for the specific Interconnect RAM Id</p>
<p><b>Arguments</b> <br  />
 <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 regOffset Byte offset of the ECC wrapper register to read (must be in the range of 0x10..0x24) <br  />
 pRegVal A pointer (of uint32_t) to hold the value of the specified EDC Interconnect register</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the arguments such as ramId and/or regOffset are invalid</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga49c65657322bb71648c2546d7cb06786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49c65657322bb71648c2546d7cb06786">&#9670;&nbsp;</a></span>SDL_ecc_aggrWriteEDCInterconnectReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrWriteEDCInterconnectReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrWriteEDCInterconnectReg</b> </p>
<p><b>Description</b> <br  />
 This function writes a value into the specified EDC Interconnect register in the specific Interconnect RAM Id</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 regOffset Byte offset of the EDC Interconnect register to write (must be in the range of 0x10..0x24) <br  />
 val The 32-bit value to write into the register</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga6fdfa8c64b72e041b8cfe0dad6a0290c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fdfa8c64b72e041b8cfe0dad6a0290c">&#9670;&nbsp;</a></span>SDL_ecc_aggrConfigEDCInterconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrConfigEDCInterconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEccCheck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrConfigEDCInterconnect</b> </p>
<p><b>Description</b> <br  />
 This function is used to configure the EDC control capabilities of the specified Interconnect RAM Id</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 bEccCheck If true, then enable ECC check.</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gae02e143af4ec1e6b395a6f34a1b6cf91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae02e143af4ec1e6b395a6f34a1b6cf91">&#9670;&nbsp;</a></span>SDL_ecc_aggrVerifyConfigEDCInterconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrVerifyConfigEDCInterconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEccCheck</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrVerifyConfigEDCInterconnect</b> </p>
<p><b>Description</b> <br  />
 This function is used to verify the configure the ECC capabilities of the specified Interconnect RAM Id</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 bEccCheck If true, then enable ECC check.</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success, indicates the configuration is successful <br  />
 SDL_EFAIL Failure, indicates the expected configuration failed <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 <a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#ga6fdfa8c64b72e041b8cfe0dad6a0290c">SDL_ecc_aggrConfigEDCInterconnect()</a> is called previously with the same arguments</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gaf5ab784ded2331716bafb8c4cd56f105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5ab784ded2331716bafb8c4cd56f105">&#9670;&nbsp;</a></span>SDL_ecc_aggrGetEDCInterconnectErrorStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrGetEDCInterconnectErrorStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL__Ecc__AggrEDCInterconnectErrorStatusInfo.html">SDL_Ecc_AggrEDCInterconnectErrorStatusInfo</a> *&#160;</td>
          <td class="paramname"><em>pEccErrorStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrGetEDCInterconnectErrorStatus</b> </p>
<p><b>Description</b> <br  />
 This function is used to get the error status of the specified Interconnect RAM Id</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 pEccErrorStatus A pointer to a <a class="el" href="structSDL__Ecc__AggrEDCInterconnectErrorStatusInfo.html" title="This structure contains error status information returned by the SDL_ecc_aggrGetEDCInterconnectErrorS...">SDL_Ecc_AggrEDCInterconnectErrorStatusInfo</a> structure containing returned error information</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gaea7ddb7bdaec0006bd369812203a9869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea7ddb7bdaec0006bd369812203a9869">&#9670;&nbsp;</a></span>SDL_ecc_aggrForceEDCInterconnectError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrForceEDCInterconnectError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSDL__Ecc__AggrEDCInterconnectErrorInfo.html">SDL_Ecc_AggrEDCInterconnectErrorInfo</a> *&#160;</td>
          <td class="paramname"><em>pEccForceError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrForceEDCInterconnectError</b> </p>
<p><b>Description</b> <br  />
 This function is used to force an ECC error on the specified Interconnect RAM Id</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 pEccForceError A pointer to a <a class="el" href="structSDL__Ecc__AggrEDCInterconnectErrorInfo.html" title="This structure contains error forcing information used by the SDL_ecc_aggrForceEDCInterconnectError f...">SDL_Ecc_AggrEDCInterconnectErrorInfo</a> structure containing force error information</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gaa3d7dd50b8746a91d710fc804e6c7f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3d7dd50b8746a91d710fc804e6c7f4f">&#9670;&nbsp;</a></span>SDL_ecc_aggrAckIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrAckIntr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrAckIntr</b> </p>
<p><b>Description</b> <br  />
 This function is used to acknowledged a pending interrupt and to send the next interrupt to the host</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT or SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT) to acknowledge</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga415b73a48902d7d2263f7b1ede627780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga415b73a48902d7d2263f7b1ede627780">&#9670;&nbsp;</a></span>SDL_ecc_aggrIsEccRamIntrPending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrIsEccRamIntrPending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pIsPend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrIsEccRamIntrPending</b> </p>
<p><b>Description</b> <br  />
 This function returns the pending interrupt status of the specified interrupt source from the specified ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT, SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT, or SDL_ECC_ADDR_ERROR_TYPE_SUCCESSIVE_SINGLE_BITS)</p>
<p><br  />
 pIsPend A Pointer (of type bool) to hold the state as below true An interrupt of the specified type is pending false An interrupt of the specified type is not pending, or the ramId and/or intrSrc arguments are invalid</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga8320e329b155a7e8e13104509a010671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8320e329b155a7e8e13104509a010671">&#9670;&nbsp;</a></span>SDL_ecc_aggrSetEccRamIntrPending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrSetEccRamIntrPending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrSetEccRamIntrPending</b> </p>
<p><b>Description</b> <br  />
 This function is used to forceably set the pending status of the specified interrupt source on the specified ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT, SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT, or SDL_ECC_ADDR_ERROR_TYPE_SUCCESSIVE_SINGLE_BITS)</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gac4ea124c43807001101e9aa63d0c521c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4ea124c43807001101e9aa63d0c521c">&#9670;&nbsp;</a></span>SDL_ecc_aggrSetEccRamNIntrPending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrSetEccRamNIntrPending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numEvents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrSetEccRamNIntrPending</b> </p>
<p><b>Description</b> <br  />
 This function is used to forceably set the pending status of the specified interrupt source on the specified ECC RAM Note that multiple events can be triggerred in one call.</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT, SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT, or SDL_ECC_ADDR_ERROR_TYPE_SUCCESSIVE_SINGLE_BITS) <br  />
 numEvents 1 - 3 are valid number of events to set; 0 or &gt; 3 invalid.</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga1371231c7a8bb6d9b501bec2bc0363f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1371231c7a8bb6d9b501bec2bc0363f3">&#9670;&nbsp;</a></span>SDL_ecc_aggrClrEccRamIntrPending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrClrEccRamIntrPending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrClrEccRamIntrPending</b> </p>
<p><b>Description</b> <br  />
 This function is used to clear the pending status of the specified interrupt source on the specified ECC RAM</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT, SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT, or SDL_ECC_ADDR_ERROR_TYPE_SUCCESSIVE_SINGLE_BITS)</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gae2a1abd9224641cb30ccbfa487676539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2a1abd9224641cb30ccbfa487676539">&#9670;&nbsp;</a></span>SDL_ecc_aggrClrEccRamNIntrPending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrClrEccRamNIntrPending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numEvents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrClrEccRamIntrPending</b> </p>
<p><b>Description</b> <br  />
 This function is used to clear the pending status of the specified interrupt source on the specified ECC RAM Note that multiple events can be cleared in one call.</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT, SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT, or SDL_ECC_ADDR_ERROR_TYPE_SUCCESSIVE_SINGLE_BITS)</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gacacd3470241b054a127dc43044385667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacacd3470241b054a127dc43044385667">&#9670;&nbsp;</a></span>SDL_ecc_aggrIsEDCInterconnectIntrPending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrIsEDCInterconnectIntrPending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pIsPend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrIsEDCInterconnectIntrPending</b> </p>
<p><b>Description</b> <br  />
 This function returns the pending interrupt status of the specified interrupt source from the specified Interconnect RAM Id</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT or SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT)</p>
<p><br  />
 pIsPend A Pointer (of type bool) to hold the state as below true An interrupt of the specified type is pending false An interrupt of the specified type is not pending, or the ramId and/or intrSrc arguments are invalid</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga19aa06a05d0208045e9d831ae731a4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19aa06a05d0208045e9d831ae731a4fc">&#9670;&nbsp;</a></span>SDL_ecc_aggrSetEDCInterconnectNIntrPending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrSetEDCInterconnectNIntrPending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#ga6dffb98cb4d267d06430adec7bba1b6b">SDL_Ecc_AggrEDCErrorSubType</a>&#160;</td>
          <td class="paramname"><em>subType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numEvents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrSetEDCInterconnectNIntrPending</b> </p>
<p><b>Description</b> <br  />
 This function is used to forceably set the pending status of the specified interrupt source on the specified Interconnect RAM Id. Note that multiple events can be triggerred in one call.</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT or SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT) <br  />
 subType Specify inject error events or normal error events. <br  />
 numEvents 1 - 3 are valid number of events to set; 0 or &gt; 3 invalid.</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga872ad1ef6ab69b7cc8cbee521a8f1477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga872ad1ef6ab69b7cc8cbee521a8f1477">&#9670;&nbsp;</a></span>SDL_ecc_aggrClrEDCInterconnectNIntrPending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrClrEDCInterconnectNIntrPending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#ga6dffb98cb4d267d06430adec7bba1b6b">SDL_Ecc_AggrEDCErrorSubType</a>&#160;</td>
          <td class="paramname"><em>subType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numEvents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrClrEDCInterconnectNIntrPending</b> </p>
<p><b>Description</b> <br  />
 This function is used to clear the pending status of the specified interrupt source on the specified Interconnect RAM Id Note that multiple events can be cleared in one call.</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT or SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT) <br  />
 subType Specify inject error events or normal error events. <br  />
 numEvents 1 - 3 are valid number of events to clear;0 or &gt; 3 invalid.</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga7e879da096e53d75be140c185280e91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e879da096e53d75be140c185280e91c">&#9670;&nbsp;</a></span>SDL_ecc_aggrIsIntrPending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrIsIntrPending </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pIsPend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrIsIntrPending</b> </p>
<p><b>Description</b> <br  />
 This function returns the pending interrupt status for the specified ECC interrupt source from the ECC RAM specified by ramId.</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT or SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT; valid only for the SDL_ecc_aggrIsIntrPending function)</p>
<p><br  />
 pIsPend A pointer (of type bool) to hold the status as below true An interrupt of the specified type is pending false An interrupt of the specified type is not pending, or the ramId and/or intrSrc arguments are invalid</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga3228be72cf5ae3a8a29b9568a6709d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3228be72cf5ae3a8a29b9568a6709d37">&#9670;&nbsp;</a></span>SDL_ecc_aggrIsAnyIntrPending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrIsAnyIntrPending </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pIsPend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrIsAnyIntrPending</b> </p>
<p><b>Description</b> <br  />
 This function returns the pending interrupt status for any interrupt source from the ECC RAM specified by ramId.</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1)</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gaf59636079aff6ba0368615abee362d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf59636079aff6ba0368615abee362d66">&#9670;&nbsp;</a></span>SDL_ecc_aggrEnableIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrEnableIntr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrEnableIntr</b> </p>
<p><b>Description</b> <br  />
 This function enables the interrupt for the specified interrupt source on the RAM specified by ramId</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT or SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT)</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga181414a69152a8365a694bd8188fbcc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga181414a69152a8365a694bd8188fbcc5">&#9670;&nbsp;</a></span>SDL_ecc_aggrDisableIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrDisableIntr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrDisableIntr</b> </p>
<p><b>Description</b> <br  />
 This function disables the interrupt for the specified interrupt source on the RAM specified by ramId</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1) <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT or SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT)</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicate the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga5c91cbaa03176e6debbe719c9e0ede79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c91cbaa03176e6debbe719c9e0ede79">&#9670;&nbsp;</a></span>SDL_ecc_aggrEnableAllIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrEnableAllIntr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrEnableAllIntr</b> </p>
<p><b>Description</b> <br  />
 This function enables the interrupts for all of the available interrupt sources on the RAM specified by ramId</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1)</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga122b80435ec40e0c48338f0277d85c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga122b80435ec40e0c48338f0277d85c52">&#9670;&nbsp;</a></span>SDL_ecc_aggrDisableAllIntr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrDisableAllIntr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrDisableAllIntr</b> </p>
<p><b>Description</b> <br  />
 This function disables the interrupts for all of the available interrupt sources on the RAM specified by ramId</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 ramId RAM identifier (0..<a class="el" href="group__SDL__ECC__AGGR__FUNCTION.html#gafd92b4adf0d5805df18662b1e1c5cd92">SDL_ecc_aggrGetNumRams()</a>-1)</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gad2e801ae78ea619187cbdce792cfe35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2e801ae78ea619187cbdce792cfe35b">&#9670;&nbsp;</a></span>SDL_ecc_aggrEnableIntrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrEnableIntrs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrEnableIntrs</b> </p>
<p><b>Description</b> <br  />
 This function enables the interrupt for the specified interrupt source on all ECC RAMs serviced by this aggregator</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT or SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT)</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gacb6719881e9194c28fb4cf1be7cd9170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb6719881e9194c28fb4cf1be7cd9170">&#9670;&nbsp;</a></span>SDL_ecc_aggrDisableIntrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrDisableIntrs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SDL__ECC__AGGR__ENUM.html#gac54924de1f429528a55d0e1c46056a59">SDL_Ecc_AggrIntrSrc</a>&#160;</td>
          <td class="paramname"><em>intrSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrDisableIntrs</b> </p>
<p><b>Description</b> <br  />
 This function disables the interrupts for the specified interrupt source on all ECC RAMs serviced by this aggregator</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 intrSrc The interrupt source (SDL_ECC_AGGR_INTR_SRC_SINGLE_BIT or SDL_ECC_AGGR_INTR_SRC_DOUBLE_BIT)</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga555808e1bf039ab2222e7fb94a606f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga555808e1bf039ab2222e7fb94a606f7b">&#9670;&nbsp;</a></span>SDL_ecc_aggrEnableAllIntrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrEnableAllIntrs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrEnableAllIntrs</b> </p>
<p><b>Description</b> <br  />
 This function enables the interrupts for all of the available interrupt sources on all ECC RAMs serviced by this aggregator</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga0b47f308f8ae4660723caf125a73f960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b47f308f8ae4660723caf125a73f960">&#9670;&nbsp;</a></span>SDL_ecc_aggrDisableAllIntrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrDisableAllIntrs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrDisableAllIntrs</b> </p>
<p><b>Description</b> <br  />
 This function disables the interrupts for all of the available interrupt sources on all ECC RAMs serviced by this aggregator</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gaa566e02e16ebbb5355649a2706bf44e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa566e02e16ebbb5355649a2706bf44e0">&#9670;&nbsp;</a></span>SDL_ecc_aggrReadStaticRegs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrReadStaticRegs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL__ECC__staticRegs.html">SDL_ECC_staticRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrStaticRegs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrReadStaticRegs</b> </p>
<p><b>Description</b> <br  />
 This function reads the static registers for ECC aggregator</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 pEccAggrStaticRegs A pointer (of type SDL_ECC_staticRegs*) to hold the static register values</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="gae6c8ec50211c9b8485e2fc2b4076e34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6c8ec50211c9b8485e2fc2b4076e34c">&#9670;&nbsp;</a></span>SDL_ecc_aggrIntrEnableCtrl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrIntrEnableCtrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrEnableCtrl.html">SDL_ecc_aggrEnableCtrl</a> *&#160;</td>
          <td class="paramname"><em>pEnableCtrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrIntrEnableCtrl</b> </p>
<p><b>Description</b> <br  />
 This function reads the static registers for ECC aggregator</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 pEnableCtrl A pointer (of type SDL_ecc_aggrEnableCtrl*) to hold the interrupt enable control values</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga315328ad1eda006e9c8729ad81fb2cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga315328ad1eda006e9c8729ad81fb2cb9">&#9670;&nbsp;</a></span>SDL_ecc_aggrIntrStatusCtrl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrIntrStatusCtrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrStatusCtrl.html">SDL_ecc_aggrStatusCtrl</a> *&#160;</td>
          <td class="paramname"><em>pStatusCtrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrIntrStatusCtrl</b> </p>
<p><b>Description</b> <br  />
 This function writes the ECC Aggregator Status registers for timeout and parity count values</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 pStatusCtrl A pointer (of type SDL_ecc_aggrStatusCtrl*) to hold the interrupt status control and count values</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
<a id="ga7fcf84d60a080c7f339f4e0d300cce4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fcf84d60a080c7f339f4e0d300cce4b">&#9670;&nbsp;</a></span>SDL_ecc_aggrIntrGetStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SDL_ecc_aggrIntrGetStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSDL__ecc__aggrRegs.html">SDL_ecc_aggrRegs</a> *&#160;</td>
          <td class="paramname"><em>pEccAggrRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSDL__ecc__aggrStatusCtrl.html">SDL_ecc_aggrStatusCtrl</a> *&#160;</td>
          <td class="paramname"><em>pStatusCtrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br  />
<b>SDL_ecc_aggrIntrGetStatus</b> </p>
<p><b>Description</b> <br  />
 This function reads the ECC Aggregator Status registers for timeout and parity count values</p>
<p><b>Arguments</b> <br  />
 pEccAggrRegs A pointer (of type SDL_ecc_aggrRegs*) to the base address of the ECC Aggregator module <br  />
 pStatusCtrl A pointer (of type SDL_ecc_aggrStatusCtrl*) to read the timeout and parity count values</p>
<p><b> Return Value </b> <br  />
 SDL_PASS Success <br  />
 SDL_EBADARGS Failure, indicates the bad input arguments</p>
<p><b> Pre Condition </b> <br  />
 None</p>
<p><b> Post Condition </b> <br  />
 None </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
